# 编译器祛魅 (Compiler Demystification)

一个用于理解编译器工作原理的教育性项目。通过从简单到复杂的渐进式实现，让编译器不再神秘。

## 🎯 项目理念

**"编译器祛魅"** —— 让编译器从"黑盒"变成"透明盒"。

传统编译器课程往往只关注理论，而本项目通过**可视化 + 交互式探索**的方式，让你能够：
- **看到** 代码如何被解析成 AST
- **追踪** 控制流如何转化为 CFG
- **理解** 作用域如何在栈上分配
- **观察** 代码如何一步步生成汇编指令
- **执行** 生成的汇编代码并查看运行时状态

## 📚 项目结构：三个层次的学习路径

项目采用**渐进式设计**，从简单到复杂，逐层深入：

### 第一层：表达式解析器（优先级爬升）

**位置**: `bnf/`, `precedence-climbing/`

**目标**: 理解**语法分析**的本质

**核心思考**:
- 如何将文本解析成树结构？
- 运算符优先级如何实现？
- 递归下降 vs 优先级爬升：两种思路的对比

**可视化**: `frontend/src/priority-climbing/`
- AST 树可视化
- 栈式执行可视化（单调栈 + 操作数栈）
- 理解优先级爬升算法的数据结构本质

**关键洞察**: 
优先级爬升算法 = **操作符单调递增栈 + 操作数栈**。递归实现只是隐式栈，栈式实现让数据结构显式化。

### 第二层：完整编译器（CFG + 作用域）

**位置**: `cfg/`, `statements/`

**目标**: 理解**控制流**和**作用域管理**

**核心思考**:
- 如何将线性代码转换为控制流图？
- 基本块（Basic Block）的本质是什么？
- 作用域如何在栈上分配和管理？
- 变量遮蔽（shadowing）如何实现？

**设计亮点**:
1. **Checkpoint 机制**: 显式标记作用域边界，将作用域管理与 CFG 结构解耦
2. **init 标志**: 区分"声明"和"初始化"，正确处理变量遮蔽
3. **快照机制**: 在 DFS 遍历中支持作用域状态的回溯

**可视化**: 
- `frontend/src/ast-cfg/`: AST 和 CFG 的可视化
- `frontend/src/stack-scope/`: 栈布局和作用域链的可视化

### 第三层：代码生成与虚拟机

**位置**: `cfg/src/assembly-generator.ts`, `cfg/src/assembly-vm.ts`

**目标**: 理解**代码生成**和**执行模型**

**核心思考**:
- 如何从 CFG 生成汇编代码？
- 栈帧如何分配和回收？
- 寄存器如何分配？
- 如何优化生成的代码（基本块合并）？

**可视化**: `frontend/src/codegen-vm/`
- 汇编代码生成过程可视化
- 虚拟机执行可视化（寄存器、栈、标志位）
- 代码优化前后对比（基本块合并）

## 🏗️ 架构设计哲学

### 1. 模块化与可扩展性

每个模块都是**独立的**，可以单独理解和使用：
- `lexer.ts`: 词法分析
- `parser.ts`: 语法分析
- `cfg-generator.ts`: CFG 生成
- `assembly-generator.ts`: 代码生成
- `assembly-vm.ts`: 虚拟机执行

**设计思考**: 
- 每个模块职责单一，易于理解
- 模块间通过清晰的接口通信
- 可以单独测试每个模块

### 2. 可视化驱动的学习

**核心思想**: 代码即文档，可视化即解释。

每个关键概念都有对应的可视化：
- **AST**: 树形结构可视化
- **CFG**: 图结构可视化
- **栈布局**: 内存布局可视化
- **虚拟机**: 执行状态可视化

**设计思考**:
- 可视化让抽象概念变得具体
- 交互式探索比静态文档更有效
- 实时反馈帮助理解动态过程

### 3. 渐进式复杂度

项目从最简单的表达式解析开始，逐步增加复杂度：
1. 表达式 → 2. 语句 → 3. 控制流 → 4. 作用域 → 5. 函数 → 6. 代码生成

**设计思考**:
- 每一步都建立在前一步的基础上
- 每个新概念都有独立的示例
- 可以随时停下来理解当前层

## 🎓 学习路径建议

### 初学者路径

1. **理解表达式解析** (`bnf/`, `precedence-climbing/`)
   - 先理解递归下降（BNF）
   - 再理解优先级爬升
   - 最后理解栈式实现（显式数据结构）

2. **探索可视化** (`frontend/src/priority-climbing/`)
   - 输入表达式，观察 AST
   - 单步执行，观察栈的变化
   - 理解优先级和结合性

3. **理解控制流** (`cfg/`)
   - 阅读 `cfg/docs/` 文档
   - 运行 `vm-runner.ts` 查看 CFG
   - 在可视化中探索 CFG 结构

4. **理解作用域** (`frontend/src/stack-scope/`)
   - 观察作用域如何创建和销毁
   - 理解变量遮蔽
   - 追踪栈上的变量分配

5. **理解代码生成** (`frontend/src/codegen-vm/`)
   - 观察汇编代码的生成过程
   - 理解代码优化（基本块合并）
   - 在虚拟机中执行并观察状态

### 进阶路径

1. **深入算法实现**
   - 研究 DFS 遍历中的快照机制
   - 理解基本块合并的优化算法
   - 探索寄存器分配策略

2. **扩展功能**
   - 添加新的数据类型
   - 实现函数调用
   - 添加更多优化

## 🔍 关键设计决策

### 为什么使用 Checkpoint 机制？

**问题**: 如何在 CFG 遍历时正确管理作用域？

**传统方案**: 在 CFG 生成时处理作用域（耦合度高）

**我们的方案**: Checkpoint 机制
- 在 AST 转换阶段显式标记作用域边界
- CFG 生成时只需识别 Checkpoint 节点
- 作用域管理与 CFG 结构解耦

**优势**: 
- 职责分离：AST 转换负责标记，CFG 生成负责控制流
- 易于理解：作用域边界清晰可见
- 易于调试：可以单独测试作用域管理

### 为什么使用 init 标志？

**问题**: 如何区分"已声明但未初始化"和"已初始化"的变量？

**传统方案**: 只记录声明，不区分初始化

**我们的方案**: init 标志
- `enterScope` 时，所有变量 `init: false`
- `int x` 或 `let x` 声明时，`init: true`
- 查找变量时，只返回 `init: true` 的变量

**优势**:
- 正确处理变量遮蔽：内层未初始化的变量不会遮蔽外层已初始化的变量
- 支持 TDZ（Temporal Dead Zone）语义
- 更接近真实编译器的实现

### 为什么使用快照机制？

**问题**: 在 CFG 的 DFS 遍历中，如何正确处理分支和回溯时的作用域状态？

**传统方案**: 每次回溯都重新计算作用域（效率低）

**我们的方案**: 快照机制
- 进入基本块时保存作用域快照
- 回溯时从快照恢复
- 使用深拷贝确保独立性

**优势**:
- 正确性：每个分支都有独立的作用域状态
- 效率：不需要重新计算
- 可调试：可以查看任意时刻的作用域状态

## 📖 文档结构

### 技术文档 (`cfg/docs/`)
- `ARCHITECTURE.md`: 系统架构和设计决策
- `IMPLEMENTATION_FLOW.md`: 编译流程详解
- `MODULES.md`: 各模块详细说明
- `BASIC_BLOCK_THEORY.md`: 基本块理论

### 代码示例 (`cfg/tests/`)
- `grade-check.txt`: 复杂的作用域和控制流示例
- `test-for-scope-*.txt`: 作用域测试
- `for-loop-test.txt`, `while-loop-test.txt`: 循环测试

## 🚀 快速开始

### 环境要求
- Bun 运行时

### 安装依赖
```bash
bun install
cd frontend && bun install
```

### 运行示例

#### 后端测试
```bash
# 运行 CFG 编译器
cd cfg
bun run src/vm-runner.ts tests/grade-check.txt

# 运行表达式解析器
cd ..
bun run precedence:stack
```

#### 前端可视化
```bash
cd frontend
bun run dev
# 访问 http://localhost:5173
```

### 探索页面

1. **栈式优先级爬升可视化** (`/`)
   - 表达式解析的栈式可视化

2. **AST CFG 测试页面** (`/ast-cfg`)
   - AST 和 CFG 的可视化
   - 代码高亮和块映射

3. **栈布局可视化** (`/stack-scope`)
   - 作用域链可视化
   - 栈布局逐步执行

4. **代码生成与虚拟机** (`/codegen-vm`)
   - 汇编代码生成
   - 代码优化（基本块合并）
   - 虚拟机执行

## 🎯 项目价值

### 教育价值
- **理论结合实践**: 不仅讲解理论，还提供完整实现
- **可视化学习**: 抽象概念通过可视化变得具体
- **渐进式学习**: 从简单到复杂，循序渐进

### 技术价值
- **模块化设计**: 每个模块都可以独立理解和使用
- **可扩展性**: 易于添加新功能
- **可调试性**: 每个阶段都有详细的输出

### 研究价值
- **算法实现**: 优先级爬升、DFS 遍历、基本块合并
- **数据结构**: 单调栈、作用域栈、快照机制
- **系统设计**: 编译器架构、模块划分、接口设计

## 🤝 贡献

欢迎贡献代码、文档、示例或改进建议！

## 📄 许可证

MIT License

---

**让编译器不再神秘，从理解开始。** 🚀
