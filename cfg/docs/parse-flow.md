1、获取到 CFG (Control Flow Graph)
2、构建 CFG，将 CFG 构建成一个基本块树状结构 (Basic Block Tree)
3、找到树的根块（即入口块），找到当前块内声明的变量，收集个数，然后 enterScope 分配，依次给变量位置，然后一步一步解析，如果找到 blockStatement/loop/while 等子块，继续 enterScope，结束子块则 exitScope。此时记录当前块已分配的总空间（这很重要）。
4、然后继续深度优先遍历自己的子基本块，找到词法作用域，判断语句，如果不是新的作用域，则收集当前基本块中最外层的词法作用域内声明的变量个数，依次分配给当前作用域内的变量（没有新变量就不用继续分配），然后执行语句，如果找到 blockStatement/loop/while 等子块，继续 enterScope，结束子块则 exitScope。进入到该子基本块之前，要记录前驱基本块已分配的空间个数和当前块在进入时的最外层词法作用域 scope map。
5、这样深度优先执行完叶子基本块，返回到前驱基本块时，通过还原前驱基本块的最外层词法作用域，继续执行下一个叶子基本块。这样在 a 叶子基本块的词法作用域的声明变量就不会在 b 叶子基本块的词法作用域中访问到。（叶子基本块指的是没有后继的基本块）
6、如果在叶子基本块中有 return 语句，那就可以直接增加需要销毁目前分配的空间个数的汇编指令，然后继续返回前驱基本块，继续递归。

## 关键概念说明

### 1. 最外层词法作用域 (Outermost Lexical Scope)
- **定义**：当前基本块中最外层的词法作用域，不包括嵌套的 `{}` 块
- **作用**：确定当前基本块中需要管理的变量作用域层次
- **实现**：收集当前基本块中最外层词法作用域内声明的变量个数

### 2. 作用域状态还原 (Scope State Restoration)
- **定义**：恢复到前驱基本块处理时的作用域状态
- **包含内容**：
  - 作用域栈的状态 (Scope Stack State)
  - 变量分配的空间 (Variable Allocated Space)
  - 变量名到偏移的映射 (Variable Name to Offset Mapping)
- **作用**：确保不同叶子基本块之间的词法作用域隔离

### 3. 叶子基本块作用域隔离 (Leaf Block Scope Isolation)
- **定义**：通过"还原前驱基本块的最外层词法作用域"来实现
- **目的**：确保每个叶子基本块都有独立的作用域状态
- **效果**：在 a 叶子基本块的词法作用域中声明的变量不会在 b 叶子基本块的词法作用域中访问到