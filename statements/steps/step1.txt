=== 生成的汇编代码 ===
; Generated assembly code
.data
  ; Variables will be declared here

.text
.global _start

_start:
  call function_main     ; 调用main函数
  exit                  ; 退出程序

function_main:
  push ebp
  mov ebp, esp
  sub esp, 2            ; 为2个函数级变量分配栈空间
  mov eax, 0         ; 加载常量 0
  SI -1              ; 初始化 sum
  mov eax, 0         ; 加载常量 0
  SI -2              ; 初始化 i
loop_0:
continue_2:
  LI -2              ; 加载变量 i
  push eax              ; 保存左操作数到栈
  mov eax, 5         ; 加载常量 5
  mov ebx, eax          ; 右操作数到ebx
  pop eax               ; 从栈恢复左操作数
  cmp eax, ebx          ; 比较操作数
  jge end_1
  sub esp, 1            ; 为1个块级变量分配栈空间
  LI -2              ; 加载变量 i
  push eax              ; 保存左操作数到栈
  mov eax, 2         ; 加载常量 2
  mov ebx, eax          ; 右操作数到ebx
  pop eax               ; 从栈恢复左操作数
  imul eax, ebx         ; 执行乘法
  SI -3              ; 初始化 let temp
  LI -1              ; 加载变量 sum
  push eax              ; 保存左操作数到栈
  LI -3              ; 加载变量 temp
  mov ebx, eax          ; 右操作数到ebx
  pop eax               ; 从栈恢复左操作数
  add eax, ebx          ; 执行加法
  SI -1              ; 存储到 sum
  LI -2              ; 加载变量 i
  push eax              ; 保存左操作数到栈
  mov eax, 1         ; 加载常量 1
  mov ebx, eax          ; 右操作数到ebx
  pop eax               ; 从栈恢复左操作数
  add eax, ebx          ; 执行加法
  SI -2              ; 存储到 i
  add esp, 1            ; 释放块级变量栈空间
  jmp loop_0
end_1:
break_3:
  LI -1              ; 加载变量 sum
  push eax        ; 参数1入栈
  ; print(1个参数)
  PRT             ; 系统调用print
  add esp, 1      ; 清理栈参数
  ; Expression result in eax
  mov eax, 0         ; 加载常量 0
  SI -3              ; 初始化for循环变量 j
loop_4:
  LI -3              ; 加载变量 j
  push eax              ; 保存左操作数到栈
  mov eax, 3         ; 加载常量 3
  mov ebx, eax          ; 右操作数到ebx
  pop eax               ; 从栈恢复左操作数
  cmp eax, ebx          ; 比较操作数
  jge end_5
  sub esp, 2            ; 为2个块级变量分配栈空间
  LI -3              ; 加载变量 j
  push eax              ; 保存左操作数到栈
  mov eax, 1         ; 加载常量 1
  mov ebx, eax          ; 右操作数到ebx
  pop eax               ; 从栈恢复左操作数
  add eax, ebx          ; 执行加法
  SI -3              ; 初始化 let multiplier
  LI -1              ; 加载变量 sum
  push eax              ; 保存左操作数到栈
  LI -3              ; 加载变量 multiplier
  mov ebx, eax          ; 右操作数到ebx
  pop eax               ; 从栈恢复左操作数
  imul eax, ebx         ; 执行乘法
  SI -4              ; 初始化 product
  LI -4              ; 加载变量 product
  push eax              ; 保存左操作数到栈
  mov eax, 30         ; 加载常量 30
  mov ebx, eax          ; 右操作数到ebx
  pop eax               ; 从栈恢复左操作数
  cmp eax, ebx          ; 比较操作数
  jle else_8
  sub esp, 1            ; 为1个块级变量分配栈空间
  mov eax, 10         ; 加载常量 10
  SI -3              ; 初始化 let bonus
  LI -4              ; 加载变量 product
  push eax              ; 保存左操作数到栈
  LI -3              ; 加载变量 bonus
  mov ebx, eax          ; 右操作数到ebx
  pop eax               ; 从栈恢复左操作数
  add eax, ebx          ; 执行加法
  SI -4              ; 存储到 product
  add esp, 1            ; 释放块级变量栈空间
else_8:
end_9:
  LI -4              ; 加载变量 product
  push eax        ; 参数1入栈
  ; print(1个参数)
  PRT             ; 系统调用print
  add esp, 1      ; 清理栈参数
  ; Expression result in eax
  add esp, 2            ; 释放块级变量栈空间
continue_6:
  LI -3              ; 加载变量 j
  push eax              ; 保存左操作数到栈
  mov eax, 1         ; 加载常量 1
  mov ebx, eax          ; 右操作数到ebx
  pop eax               ; 从栈恢复左操作数
  add eax, ebx          ; 执行加法
  SI -3             ; 存储到变量 j
  ; Expression result in eax
  jmp loop_4
end_5:
break_7:
  mov eax, 0         ; 加载常量 0
  mov esp, ebp             ; 恢复栈指针
  pop ebp                  ; 恢复调用者BP
  ret                      ; 返回调用者